为何直接对RecyclerView进行扩展而不使用ViewPager/ViewPager2？原因如下：

Scroll Model（垂直滑动）需要自定义自动滑动（对指定页进行吸附）
Flip Mode（仿真翻页）需要获取各种情况下的方向信息，以实现更好的控制
RecyclerView方便拓展，同时三种模式同时使用RecyclerView实现，便于复用
实现逻辑：三种滑动模式都在RecyclerView地基础上更改其滑动行为，横向滑动需要修改子View层级，仿真翻页需要再覆盖一层仿真动画

二、横向覆盖滑动（Slide Mode）
横向.gif

Slide Mode 最适合直接使用 ViewPager，不过我们还是以 RecyclerView 为基础来实现，让三种模式统一实现方式。实现思路：先实现跨页吸附，再实现覆盖翻页效果

1、跨页吸附
实现跨页吸附，需要在手指离开屏幕时对 RecyclerView 进行复位吸附操作，有两种情况：

（1）Scroll Idle
拖拽发生后，RecyclerView 滑动状态变为 SCROLL_STATE_IDLE 时，需要进行复位吸附操作
`// OrientationHelper为系统提供的辅助类，LayoutManager的包装类
// 可以让我们方便的计算出RecyclerView相关的各种宽高，计算结果和LayoutManager方向相关
open fun snapToTargetExistingView(helper: OrientationHelper): Pair<Int, Int>? {
    val lm = mRecyclerView.layoutManager ?: return null
    val childCount = lm.childCount // 可见数量
    if (childCount < 1) return null

    var closestChild: View? = null
    var absClosest = Int.MAX_VALUE
    var scrollDistance = 0
    // RecyclerView中心点，LayoutManager为竖向则是Y轴坐标，为横向则是X轴坐标
    val containerCenter = helper.startAfterPadding + helper.totalSpace / 2

    // 从可见Item中找到距RecyclerView离中心最近的View
    for (i in 0 until childCount) {
        val child = lm.getChildAt(i) ?: continue
        if (consumeSnap(i, child)) return null // consumeSnap 默认返回false，竖直滑动模式才使用
        val childCenter = (helper.getDecoratedStart(child)
                + helper.getDecoratedMeasurement(child) / 2)
        val absDistance = abs(childCenter - containerCenter)
        if (absDistance < absClosest) {
            absClosest = absDistance
            closestChild = child
            scrollDistance = childCenter - containerCenter
        }
    }
    closestChild ?: return null

    // 滑动
    when (orientation) {
        VERTICAL -> mRecyclerView.smoothScrollBy(0, scrollDistance)
        HORIZONTAL -> mRecyclerView.smoothScrollBy(scrollDistance, 0)
    }
    return Pair(scrollDistance, lm.getPosition(closestChild))
}`


（2）Fling
可以通过 RecyclerView 提供的OnFlingListener消费掉Fling，将其转化为 SmoothScroll ，滑动到指定位置

①、找到吸附目标的位置（adapter position）

`open fun findTargetSnapPosition(
    lm: RecyclerView.LayoutManager,
    velocity: Int,
    helper: OrientationHelper
): Int {
    val itemCount: Int = lm.itemCount
    if (itemCount == 0) return RecyclerView.NO_POSITION
    
    // 中心点以前距离最近的View
    var closestChildBeforeCenter: View? = null
    var distanceBefore = Int.MIN_VALUE	// 中心点以前，距离为负数
    // 中心点以后距离最近的View
    var closestChildAfterCenter: View? = null
    var distanceAfter = Int.MAX_VALUE	// 中心点以后，距离为正数
    val containerCenter = helper.startAfterPadding + helper.totalSpace / 2

    val childCount: Int = lm.childCount
    for (i in 0 until childCount) {
        val child = lm.getChildAt(i) ?: continue
        if (consumeSnap(i, child)) return RecyclerView.NO_POSITION // consumeSnap 默认返回false，竖直滑动模式才使用
        
        val childCenter = (helper.getDecoratedStart(child)
                + helper.getDecoratedMeasurement(child) / 2)
        val distance = childCenter - containerCenter

        // Fling需要考虑方向，先获取两个方向最近的View
        if (distance in (distanceBefore + 1)..0) {
            distanceBefore = distance
            closestChildBeforeCenter = child
        }
        if (distance in 0 until distanceAfter) {
            distanceAfter = distance
            closestChildAfterCenter = child
        }
    }
	
    // 根据方向选择Fling到哪个View
    val forwardDirection = velocity > 0
    if (forwardDirection && closestChildAfterCenter != null) {
        return lm.getPosition(closestChildAfterCenter)
    } else if (!forwardDirection && closestChildBeforeCenter != null) {
        return lm.getPosition(closestChildBeforeCenter)
    }

    // 边界情况处理
    val visibleView =
        (if (forwardDirection) closestChildBeforeCenter else closestChildAfterCenter)
            ?: return RecyclerView.NO_POSITION
    val visiblePosition: Int = lm.getPosition(visibleView)
    val snapToPosition = (visiblePosition - 1)

    return if (snapToPosition < 0 || snapToPosition >= itemCount) {
        RecyclerView.NO_POSITION
    } else snapToPosition
`
②、使用RecyclerView的「LinearSmoothScroller」完成吸附动画

`private fun createScroller(
    oh: OrientationHelper
): LinearSmoothScroller {
    return object : LinearSmoothScroller(mRecyclerView.context) {
        override fun onTargetFound(
            targetView: View,
            state: RecyclerView.State,
            action: Action
        ) {
            val d = distanceToCenter(targetView, oh)
            val time = calculateTimeForDeceleration(abs(d))
            if (time > 0) {
                when (orientation) {
                    VERTICAL -> action.update(0, d, time, mDecelerateInterpolator)
                    HORIZONTAL -> action.update(d, 0, time, mDecelerateInterpolator)
                }
            }
        }

        override fun calculateSpeedPerPixel(displayMetrics: DisplayMetrics) =
            100f / displayMetrics.densityDpi

        override fun calculateTimeForScrolling(dx: Int) =
            100.coerceAtMost(super.calculateTimeForScrolling(dx))
    }
}

protected fun distanceToCenter(targetView: View, helper: OrientationHelper): Int {
    val childCenter = (helper.getDecoratedStart(targetView)
            + helper.getDecoratedMeasurement(targetView) / 2)
    val containerCenter = helper.startAfterPadding + helper.totalSpace / 2
    return childCenter - containerCenter
}`

完整操作：

protected fun snapFromFling(
    lm: RecyclerView.LayoutManager,
    velocity: Int,
    helper: OrientationHelper
): Pair<Boolean, Int> {
    val targetPosition = findTargetSnapPosition(lm, velocity, helper)
    if (targetPosition == RecyclerView.NO_POSITION) return Pair(false, 0)
    val smoothScroller = createScroller(helper)
    smoothScroller.targetPosition = targetPosition
    lm.startSmoothScroll(smoothScroller)
    return Pair(true, targetPosition) // 消费fling
}
2、覆盖效果实现
（1）如果使用PageTransform实现
如果使用ViewPager的PageTransform，是可以实现覆盖动画的，实现思路：使可见View的第二个View跟随屏幕滑动

假设上图蓝色透明矩形为屏幕，其他为ItemView，图片上半部分正常滑动的状态，下半部分为 translate view 之后的状态。可以看到，在横向滑动过程中，最多可见2个View（蓝色透明方框最多覆盖2个View），此时将第二个View跟随屏幕，其他View保持跟随画布滑动，即可达到效果。在OnPageScroll回调中实现这个逻辑：

for (i in 0 until layoutManager.childCount) {
    layoutManager.getChildAt(i)?.also { view ->
        if (i == 1) {
            // view.left是个负数，offsetPx（=-view.left）是个正数
            view.translationX = offsetPx.toFloat() - view.width // 需要translate的距离（向前移需要负数）
        } else {
            // 恢复其余位置的translate
            view.translationX = 0f
        }
    }
}
（2）扩展RecyclerView实现覆盖翻页
知道如何通过 PageTransfrom 实现后，我们来看看直接使用 RecyclerView 如何实现。观看ViewPager2源码可知PageTransfrom的实现方式
故我们直接copy代码，在OnScrollListener中自行实现onPageScrolled回调即可实现覆盖翻页效果。

但是此时还有一个问题，就是子View的层级问题，你会发现上面的滑动示意图中，绿色View会在黄色View之上，如何解决这个问题呢？我们需要控制View的绘制顺序，前面的View后绘制，保证前面地View在后面的View的绘制层级之上。

观看源码会发现，RecyclerView其实提供了一个回调ChildDrawingOrderCallback，可以很方便地实现这个效果：

override fun attach() {
    super.attach()
    mRecyclerView.setChildDrawingOrderCallback(this)
}

override fun onGetChildDrawingOrder(childCount: Int, i: Int) = childCount - i - 1 // 反向绘制
